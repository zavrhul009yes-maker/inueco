# Экзаменационное задание: Анализ результатов спортивного турнира

## Описание задания

Вам необходимо разработать систему анализа результатов футбольного турнира. Система состоит из 5 функций, которые последовательно обрабатывают данные о матчах и вычисляют различные статистики.

---

## Функция 1: `parse_match_data(match_string)`

### Описание
Функция парсит строку с информацией о матче и возвращает структурированные данные.

### Входные данные
- `match_string` (str): строка формата `"YYYY-MM-DD | Team1 (X:Y) Team2 | Stadium | Attendance"`

**Формат строки:**
- Дата в формате `YYYY-MM-DD` (год-месяц-день)
- Разделитель ` | ` (пробел, вертикальная черта, пробел)
- Название первой команды (может содержать буквы, цифры, подчёркивания)
- Счёт в скобках `(X:Y)` где X и Y - неотрицательные целые числа
- Название второй команды
- Название стадиона
- Посещаемость (целое положительное число)

**Пример валидной строки:**
```
"2024-03-15 | Team_A (3:1) Team_B | Stadium_X | 45000"
```

### Выходные данные
Словарь со следующими ключами:
```python
{
    "date": str,           # "2024-03-15"
    "team1": str,          # "Team_A"
    "score1": int,         # 3
    "team2": str,          # "Team_B"
    "score2": int,         # 1
    "stadium": str,        # "Stadium_X"
    "attendance": int      # 45000
}
```

### Валидация и исключения

Функция должна выбрасывать исключение `ValueError` в следующих случаях:

1. **Неверное количество частей** (должно быть ровно 4 части, разделённые ` | `):
   - Сообщение: `"Invalid format: expected 4 parts separated by ' | '"`

2. **Неверный формат даты** (не соответствует `YYYY-MM-DD` или содержит недопустимые значения):
   - Сообщение: `"Invalid date format: expected YYYY-MM-DD"`
   - Дата должна быть валидной (месяц 1-12, день соответствует месяцу)

3. **Неверный формат команд и счёта** (должен быть `Team1 (X:Y) Team2`):
   - Сообщение: `"Invalid teams/score format: expected 'Team1 (X:Y) Team2'"`

4. **Счёт не является целым числом или отрицательный**:
   - Сообщение: `"Invalid score: must be non-negative integers"`

5. **Посещаемость не является положительным целым числом**:
   - Сообщение: `"Invalid attendance: must be a positive integer"`

6. **Пустые названия команд или стадиона**:
   - Сообщение: `"Team names and stadium cannot be empty"`

### Примеры

**Валидный вход:**
```python
result = parse_match_data("2024-03-15 | TeamA (3:1) TeamB | MainStadium | 45000")
# Результат: {"date": "2024-03-15", "team1": "TeamA", "score1": 3, ...}
```

**Невалидный вход:**
```python
parse_match_data("2024-03-15 | TeamA 3:1 TeamB")  # ValueError: неверное количество частей
parse_match_data("2024-13-01 | TeamA (3:1) TeamB | Stadium | 1000")  # ValueError: неверная дата
parse_match_data("2024-03-15 | TeamA (3:X) TeamB | Stadium | 1000")  # ValueError: неверный счёт
```

---

## Функция 2: `filter_matches_by_criteria(matches_list, **criteria)`

### Описание
Функция фильтрует список матчей по произвольным критериям, переданным как именованные аргументы.

### Входные данные
- `matches_list` (list): список словарей матчей (формат из функции 1)
- `**criteria`: произвольные именованные параметры для фильтрации

### Поддерживаемые критерии

- `team` (str): матч должен включать эту команду (team1 или team2)
- `date_from` (str): дата матча >= указанной (формат YYYY-MM-DD)
- `date_to` (str): дата матча <= указанной (формат YYYY-MM-DD)
- `min_attendance` (int): посещаемость >= указанного значения
- `max_attendance` (int): посещаемость <= указанного значения
- `min_total_goals` (int): сумма голов в матче >= указанного значения
- `stadium` (str): матч проходил на указанном стадионе

**Все критерии применяются одновременно (логика AND).**

### Выходные данные
Список словарей матчей, удовлетворяющих всем указанным критериям.

### Примеры

```python
matches = [
    {"date": "2024-03-15", "team1": "TeamA", "score1": 3, "team2": "TeamB", "score2": 1, "stadium": "StadiumX", "attendance": 45000},
    {"date": "2024-03-16", "team1": "TeamC", "score1": 2, "team2": "TeamA", "score2": 2, "stadium": "StadiumY", "attendance": 30000},
    {"date": "2024-03-17", "team1": "TeamB", "score1": 1, "team2": "TeamC", "score2": 0, "stadium": "StadiumX", "attendance": 25000}
]

# Фильтр: матчи команды TeamA с посещаемостью >= 40000
result = filter_matches_by_criteria(matches, team="TeamA", min_attendance=40000)
# Результат: [первый матч]

# Фильтр: матчи на StadiumX с >= 4 голами
result = filter_matches_by_criteria(matches, stadium="StadiumX", min_total_goals=4)
# Результат: [первый матч]
```

---

## Функция 3: `calculate_advanced_team_stats(matches_list)`

### Описание
Функция вычисляет расширенную статистику для каждой команды на основе списка матчей.

### Входные данные
- `matches_list` (list): список словарей матчей

### Выходные данные
Словарь, где ключ - название команды, значение - словарь со статистикой:

```python
{
    "TeamA": {
        "points": int,              # Очки (победа=3, ничья=1, поражение=0)
        "matches_played": int,      # Количество сыгранных матчей
        "wins": int,                # Количество побед
        "draws": int,               # Количество ничьих
        "losses": int,              # Количество поражений
        "goals_for": int,           # Забитые голы
        "goals_against": int,       # Пропущенные голы
        "goal_diff": int,           # Разница мячей (goals_for - goals_against)
        "home_points": int,         # Очки в матчах дома (когда команда - team1)
        "away_points": int,         # Очки в матчах в гостях (когда команда - team2)
        "win_streak": int,          # Текущая серия побед подряд
        "avg_attendance": float     # Средняя посещаемость матчей команды (округлить до 2 знаков)
    }
}
```

### Важные детали

1. **Домашние/выездные матчи**: команда играет дома, когда она находится в позиции `team1`, и в гостях, когда в позиции `team2`.

2. **Серия побед (`win_streak`)**: 
   - Количество побед подряд на текущий момент
   - Матчи должны рассматриваться в хронологическом порядке (по дате)
   - Если последний матч не победа, то win_streak = 0
   - Пример: если последние матчи команды WWLWW, то win_streak = 2

3. **Средняя посещаемость**: среднее арифметическое посещаемости всех матчей команды (независимо от дома/гостей), округлённое до 2 знаков после запятой.

4. Если команда не участвовала ни в одном матче, её не должно быть в результирующем словаре.

### Пример

```python
matches = [
    {"date": "2024-03-15", "team1": "TeamA", "score1": 3, "team2": "TeamB", "score2": 1, "attendance": 45000, ...},
    {"date": "2024-03-16", "team1": "TeamC", "score1": 2, "team2": "TeamA", "score2": 2, "attendance": 30000, ...},
    {"date": "2024-03-17", "team1": "TeamA", "score1": 2, "team2": "TeamC", "score2": 0, "attendance": 40000, ...}
]

stats = calculate_advanced_team_stats(matches)
# stats["TeamA"] = {
#     "points": 7,  # 3 (победа) + 1 (ничья) + 3 (победа)
#     "matches_played": 3,
#     "wins": 2,
#     "draws": 1,
#     "losses": 0,
#     "goals_for": 7,
#     "goals_against": 3,
#     "goal_diff": 4,
#     "home_points": 6,  # первый и третий матчи (дома)
#     "away_points": 1,  # второй матч (в гостях)
#     "win_streak": 1,   # последний матч - победа
#     "avg_attendance": 38333.33
# }
```

---

## Функция 4: `rank_teams_advanced(team_stats, tiebreaker_order=['points', 'goal_diff', 'goals_for'])`

### Описание
Функция ранжирует команды с учётом каскадной сортировки при равенстве очков.

### Входные данные
- `team_stats` (dict): словарь статистики команд из функции 3
- `tiebreaker_order` (list): список критериев для разрешения равенства (по умолчанию `['points', 'goal_diff', 'goals_for']`)

### Поддерживаемые критерии сортировки
- `"points"` - очки (больше - лучше)
- `"goal_diff"` - разница мячей (больше - лучше)
- `"goals_for"` - забитые голы (больше - лучше)
- `"wins"` - количество побед (больше - лучше)

### Выходные данные
Список кортежей в формате:
```python
[(rank, team_name, points, goal_diff), ...]
```

Отсортированный по убыванию согласно `tiebreaker_order`.

### Правила ранжирования

1. Первый критерий в `tiebreaker_order` - основной (обычно points)
2. При равенстве по первому критерию используется второй критерий, и т.д.
3. **Ранги должны учитывать равенство**: если две команды на одинаковых позициях, они получают одинаковый ранг, а следующая команда пропускает ранг
   - Пример: 1, 2, 2, 4 (а не 1, 2, 2, 3)

### Примеры

```python
stats = {
    "TeamA": {"points": 9, "goal_diff": 5, "goals_for": 10, "wins": 3},
    "TeamB": {"points": 7, "goal_diff": 3, "goals_for": 8, "wins": 2},
    "TeamC": {"points": 7, "goal_diff": 3, "goals_for": 7, "wins": 2},
    "TeamD": {"points": 4, "goal_diff": -2, "goals_for": 5, "wins": 1}
}

table = rank_teams_advanced(stats, ['points', 'goal_diff', 'goals_for'])
# Результат:
# [
#     (1, "TeamA", 9, 5),
#     (2, "TeamB", 7, 3),   # При равенстве points и goal_diff, больше goals_for
#     (3, "TeamC", 7, 3),
#     (4, "TeamD", 4, -2)
# ]

# С другим порядком критериев:
table2 = rank_teams_advanced(stats, ['points', 'wins', 'goal_diff'])
# При равенстве points (7) у TeamB и TeamC, проверяем wins (оба 2), затем goal_diff (оба 3)
# Порядок может зависеть от стабильности сортировки
```

---

## Функция 5: `generate_analytics_report(matches_list, team_stats, tournament_table)`

### Описание
Функция генерирует итоговый аналитический отчёт на основе всех собранных данных.

### Входные данные
- `matches_list` (list): список всех матчей
- `team_stats` (dict): статистика команд из функции 3
- `tournament_table` (list): турнирная таблица из функции 4

### Выходные данные
Словарь с аналитикой:

```python
{
    "tournament_leader": str,           # Название команды на 1 месте
    
    "most_goals_match": dict,           # Матч с наибольшим суммарным количеством голов
                                        # Формат: полный словарь матча из matches_list
                                        # При равенстве - первый найденный
    
    "highest_attendance_match": dict,   # Матч с наибольшей посещаемостью
                                        # При равенстве - первый найденный
    
    "most_efficient_team": str,         # Команда с наибольшим points/matches_played
                                        # Результат округлить до 2 знаков для сравнения
                                        # При равенстве - любая из них
    
    "biggest_upset": dict or None,      # Матч, где команда с худшим рангом победила команду с лучшим
                                        # Формат: {"match": dict, "winner_rank": int, "loser_rank": int}
                                        # Самая большая разница в рангах (loser_rank - winner_rank)
                                        # Если таких матчей нет - None
    
    "goal_distribution": dict,          # Распределение общего количества голов в матчах
                                        # Формат: {total_goals: count}
                                        # Пример: {2: 5, 3: 8, 4: 12} - 5 матчей с 2 голами и т.д.
    
    "attendance_by_team": dict          # Средняя посещаемость для матчей каждой команды
                                        # Формат: {team_name: avg_attendance}
                                        # Округлить до 2 знаков после запятой
}
```

### Важные детали

1. **most_efficient_team**: вычисляется как `points / matches_played`. Используйте округление до 2 знаков для корректного сравнения.

2. **biggest_upset**: 
   - Рассматриваются только матчи с победителем (не ничьи)
   - Ранг берётся из `tournament_table` (итоговый ранг)
   - "Upset" = команда с большим номером ранга (хуже) победила команду с меньшим рангом (лучше)
   - Выбирается матч с максимальной разницей `loser_rank - winner_rank`
   - Если команды из матча нет в турнирной таблице, такой матч игнорируется

3. **goal_distribution**: ключи - это суммарное количество голов в матче (score1 + score2)

4. **attendance_by_team**: берётся из уже вычисленного `avg_attendance` в `team_stats`

### Пример

```python
report = generate_analytics_report(matches, stats, table)
# {
#     "tournament_leader": "TeamA",
#     "most_goals_match": {...},  # матч с максимум голов
#     "highest_attendance_match": {...},
#     "most_efficient_team": "TeamA",  # 9/3 = 3.0
#     "biggest_upset": {
#         "match": {...},
#         "winner_rank": 4,
#         "loser_rank": 1
#     },
#     "goal_distribution": {2: 1, 4: 2, 3: 1},
#     "attendance_by_team": {"TeamA": 38333.33, "TeamB": 35000.0, ...}
# }
```

---

## Требования к реализации

1. Все функции должны быть **чистыми** (pure functions) - не использовать `print()`, не модифицировать входные данные
2. Обрабатывать граничные случаи (пустые списки, отсутствие данных)
3. Функция 1 обязательно должна выполнять все проверки валидации
4. Код должен быть читаемым и следовать PEP 8
5. Использовать осмысленные имена переменных
6. Все вычисления с плавающей точкой округлять до 2 знаков после запятой где указано

---

## Формат сдачи

Создайте файл `tournament_analysis.py` со всеми пятью функциями. Функции должны быть определены в том порядке, в котором они описаны в задании.

**Удачи!**
